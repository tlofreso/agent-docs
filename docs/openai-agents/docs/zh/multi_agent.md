---
search:
  exclude: true
---
# 智能体编排

编排是指你应用中智能体的流程。哪些智能体运行、按什么顺序运行，以及它们如何决定下一步发生什么？主要有两种智能体编排方式：

1. 让LLM做决策：利用LLM的智能进行规划、推理，并据此决定采取哪些步骤。
2. 通过代码编排：通过你的代码来确定智能体流程。

你可以混合使用这些模式。每种方式都有各自的权衡，详见下文。

## 通过LLM编排

智能体是配备了指令、工具调用和任务转移的LLM。这意味着，对于开放式任务，LLM可以自主规划如何完成任务，使用工具采取行动并获取数据，并通过任务转移将任务委派给子智能体。例如，一个研究智能体可以配备如下工具：

-   网络检索，用于在线查找信息
-   文件检索与检索回传，用于搜索专有数据和连接
-   计算机操作，用于在计算机上执行操作
-   代码执行，用于进行数据分析
-   向擅长规划、报告撰写等工作的专门智能体进行任务转移

### 核心SDK模式

在 Python SDK 中，最常见的两种编排模式是：

| 模式 | 工作方式 | 最适用场景 |
| --- | --- | --- |
| Agents as tools | 管理智能体保持对对话的控制，并通过 `Agent.as_tool()` 调用专家智能体。 | 你希望由一个智能体负责最终答案、整合多个专家的输出，或在一个位置统一执行共享安全防护措施。 |
| 任务转移 | 分流智能体将对话路由给某个专家，该专家在本轮剩余时间内成为活动智能体。 | 你希望由专家直接回复、保持提示词聚焦，或在不由管理者转述结果的情况下切换指令。 |

当专家只需协助完成边界清晰的子任务、但不应接管面向用户的对话时，使用**Agents as tools**。当“路由”本身就是工作流的一部分，且你希望被选中的专家主导下一阶段交互时，使用**任务转移**。

你也可以将两者结合。一个分流智能体可以先转移给专家，而该专家仍可将其他智能体作为工具调用来处理更窄的子任务。

这种模式非常适合开放式任务，且你希望依赖LLM的智能。这里最重要的策略是：

1. 投入高质量提示词。明确可用工具、如何使用它们，以及它必须遵守的参数边界。
2. 监控并迭代你的应用。找出问题出现的位置，并迭代优化提示词。
3. 允许智能体自省与改进。例如，让它在循环中运行并自我评估；或提供错误信息并让它自行改进。
4. 使用在单一任务上表现卓越的专门智能体，而不是期望一个通用智能体样样精通。
5. 投入使用[评测](https://platform.openai.com/docs/guides/evals)。这能让你训练智能体持续改进并更擅长任务。

如果你想了解这种编排风格背后的核心 SDK 基本组件，请从[工具](tools.md)、[任务转移](handoffs.md)和[运行智能体](running_agents.md)开始。

## 通过代码编排

虽然通过LLM编排很强大，但通过代码编排能让任务在速度、成本和性能方面更具确定性和可预测性。常见模式包括：

-   使用[structured outputs](https://platform.openai.com/docs/guides/structured-outputs)生成你可在代码中检查的格式良好的数据。例如，你可以让智能体先将任务分类到若干目录，再根据目录选择下一个智能体。
-   串联多个智能体：将前一个智能体的输出转换为下一个智能体的输入。你可以把“撰写博客文章”拆解为一系列步骤——做研究、写大纲、写文章、进行评审，然后改进。
-   在 `while` 循环中运行执行任务的智能体，并配合一个负责评估和反馈的智能体，直到评估者判定输出通过特定标准。
-   并行运行多个智能体，例如使用 Python 基本组件 `asyncio.gather`。当多个任务彼此不依赖时，这对提速很有帮助。

我们在 [`examples/agent_patterns`](https://github.com/openai/openai-agents-python/tree/main/examples/agent_patterns) 中提供了多个示例。

## 相关指南

-   [智能体](agents.md)：了解组合模式与智能体配置。
-   [工具](tools.md#agents-as-tools)：了解 `Agent.as_tool()` 与管理者风格编排。
-   [任务转移](handoffs.md)：了解专门智能体之间的委派。
-   [运行智能体](running_agents.md)：了解按次运行的编排控制与对话状态。
-   [快速开始](quickstart.md)：查看最小化端到端任务转移示例。